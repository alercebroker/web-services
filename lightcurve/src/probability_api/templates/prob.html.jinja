<script id="htmx-script" src="https://unpkg.com/htmx.org@1.9.11"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script  type="module" src="{{API_URL}}/static/probability.js"></script>
<link rel="stylesheet" href="{{API_URL}}/static/probability.css">

<div id="probabilities-app" class="tw-preflight tw-w-full tw-bg-white dark:tw-bg-[#1e1e1e]">
    <div class="tw-flex tw-flex-col tw-items-center tw-rounded-[6px]">

        <div id="selectContainer" class="tw-flex tw-justify-center tw-my-4 tw-mx-auto tw-w-full">
            <select name="selectClassifier" id="selectClassifier" class="tw-w-[80%] hover:tw-bg-[#757575] tw-bg-transparent tw-border-b tw-border-b-[#1e1e1e] dark:tw-border-b-white">
                <optgroup class="tw-bg-white dark:tw-bg-[#1e1e1e] dark:tw-text-white">
                    <option value="#" class="tw-hidden">
                    </option>
                    {% for x in class_dict %}
                         {% for key, value in x.items() %}
                            <option value="{{key}}">{{value}}</option>
                         {% endfor %}
                    {% endfor %}
                </optgroup>
            </select>

        </div>

        <div class="md:tw-w-[80%] md:tw-h-[80%] sm:tw-w-[100%] sm:tw-h-[100%] tw-mx-auto tw-relative">
            <canvas id="myChart"></canvas>
        </div>

    </div>
</div>


<script type="module">
import { init } from "{{API_URL}}/static/probability.js";
  init();
</script>

<script id="probabilities-data" type="application/json">
{ 
   "taxonomy_dict": {{taxonomy_dict | tojson}},
   "group_prob_dict": {{group_prob_dict | tojson}}
}
</script>

<script type="module">
/*
    const raw_tax = {{taxonomy_dict | tojson}};
    const raw_group_prob_dict = {{ group_prob_dict | tojson }}
    const ctx = document.getElementById('myChart');

    

    let select = document.getElementById('selectClassifier')
    let mychart
    let probability_data_aux

    let data = {
        labels: [],
        datasets: [{
            label: 'Probabilities',
            data: [],
            fill: true,
            backgroundColor: 'rgba(255, 0, 54, 0.7)',
            borderColor: 'rgb(255, 0, 54)',
            pointBackgroundColor: 'rgb(255, 0, 54)',
            pointBorderColor: '#fff',
            pointHoverBackgroundColor: '#fff',
            pointHoverBorderColor: 'rgb(255, 0, 54)',
        }]
    };


    let config = {
        type: 'radar',
        data: data,
        options: {
            responsive: true,
            maintainAspectRatio: false,
            elements: {
                line: {
                    borderWidth: 1,
                    fill: true,
                }
            },
            scales: {
                r: {
                    backgroundColor: 'white',
                    ticks: {
                        display: false,
                        stepSize: 0.33,
                    },
                    angleLines: {
                        color: '#000000'
                    },
                    grid: {
                        color: '#000000',
                    },
                    pointLabels: {
                        color: '#000000'
                    },
                    beginAtZero: true,
                    max: 1
                },
            },
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    enabled: true,
                    mode: 'dataset',
                    position: 'nearest',
                    callbacks: {
                        title: function(){
                            return "Probability"
                        },
                        label: function(context){
                            let tooltipslabels = []
                            let label = ""
                            label = context.label + ": " + context.parsed.r
                            tooltipslabels.push(label)
                            return tooltipslabels
                        }
                    }
                }
            },
        }
    }

    init()

    function init(){
        probability_data_aux = []

        reverseData()

        mychart = new Chart(ctx, config);

        select.addEventListener('change', (e) => {
            updateMyChart(e.target.value)
        })
    }


    function reverseData(){
        let aux_arr = []

        Object.keys(raw_tax).forEach((key) => {
            aux_arr= raw_tax[key].classes.map((item, idx) => {
                if (idx == 0) {
                    return item
                } else {
                    return raw_tax[key].classes[raw_tax[key].classes.length - idx]
                }
            })
            raw_tax[key].classes = aux_arr
        })
    }


    function orderDataByTagNew(classifier_name, labels_tags, classifier_data){
        probability_data_aux.length = 0

        labels_tags.forEach((e) => {
            classifier_data.forEach((element) => {
                if(element.class_name == e){
                    probability_data_aux.push(element.probability)
                }
            })
        })
    }

    function maxValue(classifier_name, classifier_data){

        let maxVal = Math.max.apply(Math, classifier_data.map((e) => e.probability))

        return maxVal
    }

    function getScale(max_value){
        return (max_value/3)
    }

    function updateMyChart(classifier_name){
        let max_value
        let classes_arr = raw_tax[classifier_name].classes
        let classifier_data = Object.values(raw_group_prob_dict[classifier_name])[0]

        orderDataByTagNew(classifier_name, classes_arr, classifier_data)

        max_value = maxValue(classifier_name, classifier_data)

        removeDataChart()
        updateDataChart(classes_arr, max_value)

        isDark();
    }

    function removeDataChart(){
        mychart.data.labels.length = 0;
        mychart.data.datasets.forEach((dataset) => {
            dataset.data.length = 0;

        });

        mychart.update();
    }

    function updateDataChart(labels, max_value){
        mychart.data.labels.push(...labels);
        mychart.data.datasets.forEach((dataset) => {
            dataset.data.push(...probability_data_aux);
        });

        mychart.config.options.scales.r.ticks.stepSize = getScale(max_value)
        mychart.config.options.scales.r.max = max_value

        mychart.update();
    }

    function isDark(){
        if(document.getElementById("probabilities-app").classList.contains("tw-dark")){
            mychart.config.options.scales.r.backgroundColor = '#BDBDBD'
            mychart.config.options.scales.r.angleLines.color = '#EEEEEE'
            mychart.config.options.scales.r.grid.color = '#EEEEEE'
            mychart.config.options.scales.r.pointLabels.color = '#EEEEEE'
            
            mychart.update();
        }
    }
    */
</script>