<script id="htmx-script" src="https://unpkg.com/htmx.org@1.9.11"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<link rel="stylesheet" href="{{API_URL}}/static/probability.css">

<div id="probabilities-app" class="tw-preflight tw-w-full tw-bg-white dark:tw-bg-[#1e1e1e]">
    <div class="tw-flex tw-flex-col tw-items-center tw-rounded-[6px]">

        <div id="selectContainer" class="tw-flex tw-justify-center tw-my-4 tw-mx-auto tw-w-full">
            <select name="selectClassifier" id="selectClassifier" class="tw-w-[50%] hover:tw-bg-[#757575] tw-bg-transparent tw-border-b tw-border-b-[#1e1e1e] dark:tw-border-b-white">
                <optgroup class="tw-bg-white dark:tw-bg-[#1e1e1e] dark:tw-text-white">
                    <option value="#" class="tw-hidden"></option>
                    {% for key, value in class_dict.items() %}
                        <option value="{{key}}">{{value}}</option>
                    {% endfor %}
                </optgroup>
            </select>

        </div>

        <div class="md:tw-w-[50%] md:tw-h-[50%] sm:tw-w-[10%] sm:tw-h-[10%] tw-mx-auto tw-relative">
            <canvas id="myChart"></canvas>
        </div>

    </div>
</div>

<script type="module">
    const raw_tax = {{taxonomy_dict | tojson}};
    const raw_group_prob_dict = {{ group_prob_dict | tojson }}
    const ctx = document.getElementById('myChart');

    

    let select = document.getElementById('selectClassifier')
    let mychart
    let probability_data_aux

    let data = {
        labels: [],
        datasets: [{
            label: 'Probabilities',
            data: [],
            fill: true,
            backgroundColor: 'rgba(255, 0, 54, 0.7)',
            borderColor: 'rgb(255, 0, 54)',
            pointBackgroundColor: 'rgb(255, 0, 54)',
            pointBorderColor: '#fff',
            pointHoverBackgroundColor: '#fff',
            pointHoverBorderColor: 'rgb(255, 0, 54)',
        }]
    };


    let config = {
        type: 'radar',
        data: data,
        options: {
            responsive: true,
            maintainAspectRatio: false,
            elements: {
                line: {
                    borderWidth: 1,
                    fill: true,
                }
            },
            scales: {
                r: {
                    backgroundColor: 'white',
                    ticks: {
                        display: false,
                        maxTicksLimit: 5,
                    },
                    angleLines: {
                        color: '#000000'
                    },
                    grid: {
                        color: '#000000',
                    },
                    pointLabels: {
                        color: '#000000'
                    },
                    suggestedMin: 0,
                    suggestedMax: 1
                },
            },
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    enabled: true,
                    mode: 'dataset',
                    position: 'nearest',
                    callbacks: {
                        title: function(){
                            return "Probability"
                        },
                        label: function(context){
                            let tooltipslabels = []
                            let label = ""
                            label = context.label + ": " + context.parsed.r
                            tooltipslabels.push(label)
                            return tooltipslabels
                        }
                    }
                }
            },
        }
    }

    init()

    function init(){
        probability_data_aux = []
        reverseData()

        mychart = new Chart(ctx, config);

        select.addEventListener('change', (e) => {
            updateMyChart(e.target.value)
        })
    }


    function groupBy(data, prop){
        return data.reduce((groups, item) => {
            const val = item[prop]
            groups[val] = groups[val] || []
            groups[val].push(item)
            return groups
        }, {})
    }
    




    function reverseData(){
        let aux_arr = []

        Object.keys(raw_tax).forEach((key) => {
            aux_arr= raw_tax[key].classes.map((item, idx) => {
                if (idx == 0) {
                    return item
                } else {
                    return raw_tax[key].classes[raw_tax[key].classes.length - idx]
                }
            })
            raw_tax[key].classes = aux_arr
        })
    }


    function orderDataByTagNew(classifier_name, labels_tags){
        probability_data_aux.length = 0

        labels_tags.forEach((e) => {
            Object.values(raw_group_prob_dict[classifier_name])[0].forEach((element) => {
                if(element.class_name == e){
                    probability_data_aux.push(element.probability)
                }
            })
        })
    }

    function maxValue(classifier_name){

        let maxVal = Math.max.apply(Math, Object.values(raw_group_prob_dict[classifier_name])[0].map((e) => e.probability))

        return maxVal
    }

    function updateMyChart(classifier_name){
        let max_value
        let classes = raw_tax[classifier_name].classes

        console.log(raw_group_prob_dict)
        orderDataByTagNew(classifier_name, classes)

        max_value = maxValue(classifier_name)

        removeDataChart()
        updateDataChart(classes, max_value)

        isDark();
    }

    function removeDataChart(){
        mychart.data.labels.length=0;
        mychart.data.datasets.forEach((dataset) => {
            dataset.data.length=0;

        });
        mychart.update();
    }

    function updateDataChart(labels, max_value){
        mychart.data.labels.push(...labels);
        mychart.data.datasets.forEach((dataset) => {
            dataset.data.push(...probability_data_aux);
        });

        mychart.config.options.scales.r.suggestedMax = max_value

        mychart.update();
    }

    function isDark(){
        if(document.getElementById("probabilities-app").classList.contains("tw-dark")){
            mychart.config.options.scales.r.backgroundColor = '#BDBDBD'
            mychart.config.options.scales.r.angleLines.color = '#EEEEEE'
            mychart.config.options.scales.r.grid.color = '#EEEEEE'
            mychart.config.options.scales.r.pointLabels.color = '#EEEEEE'
            
            mychart.update();
        }
    }
</script>