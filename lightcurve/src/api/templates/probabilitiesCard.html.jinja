<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Probabilities</title>
    <link rel="stylesheet" href="{{API_URL}}/static/main.css">

</head>

<body class="tw-preflight dark:tw-bg-black tw-dark tw-flex tw-justify-center tw-h-[100vh]">

    <div class="tw-bg-white tw-shadow-2xl dark:tw-bg-[#1e1e1e] tw-w-[750px] tw-rounded-[6px] tw-box-content tw-p-[10px] tw-relative tw-mt-3 tw-ml-3">

        <div class="tw-flex tw-justify-center tw-border-solid tw-border-yellow-400">
            <select id="mySelect" class="tw-appearance-none tw-text-white tw-bg-[#1e1e1e] tw-border-[0px] tw-outline-[0px] tw-border-b-[2px] tw-border-[#1e1e1e] tw-border-b-white tw-w-[50%]">
            </select>
        </div>

        <div class="tw-flex tw-w-[50%] tw-h-[50%] tw-justify-center">
            <canvas id="myChart"></canvas>
        </div>

    </div>



    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <script>

        let db = [{ "classifier_name": "lc_classifier", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "SNIa", "probability": 0.066, "ranking": 4 }, { "classifier_name": "lc_classifier_periodic", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "LPV", "probability": 0.308, "ranking": 1 }, { "classifier_name": "lc_classifier_stochastic", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "QSO", "probability": 0.028, "ranking": 4 }, { "classifier_name": "lc_classifier_top", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "Transient", "probability": 1.0, "ranking": 1 }, { "classifier_name": "lc_classifier_transient", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "SNIa", "probability": 0.066, "ranking": 4 }, { "classifier_name": "stamp_classifier", "classifier_version": "stamp_classifier_1.0.0", "class_name": "SN", "probability": 0.79377556, "ranking": 1 }, { "classifier_name": "lc_classifier", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "SNIbc", "probability": 0.12, "ranking": 3 }, { "classifier_name": "lc_classifier_periodic", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "E", "probability": 0.068, "ranking": 6 }, { "classifier_name": "lc_classifier_stochastic", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "AGN", "probability": 0.076, "ranking": 3 }, { "classifier_name": "lc_classifier_top", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "Stochastic", "probability": 0.0, "ranking": 2 }, { "classifier_name": "lc_classifier_transient", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "SNIbc", "probability": 0.12, "ranking": 3 }, { "classifier_name": "stamp_classifier", "classifier_version": "stamp_classifier_1.0.0", "class_name": "AGN", "probability": 0.054537576, "ranking": 3 }, { "classifier_name": "lc_classifier", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "SNII", "probability": 0.666, "ranking": 1 }, { "classifier_name": "lc_classifier_periodic", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "DSCT", "probability": 0.072, "ranking": 5 }, { "classifier_name": "lc_classifier_stochastic", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "Blazar", "probability": 0.132, "ranking": 2 }, { "classifier_name": "lc_classifier_top", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "Periodic", "probability": 0.0, "ranking": 2 }, { "classifier_name": "lc_classifier_transient", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "SNII", "probability": 0.666, "ranking": 1 }, { "classifier_name": "stamp_classifier", "classifier_version": "stamp_classifier_1.0.0", "class_name": "VS", "probability": 0.06481175, "ranking": 2 }, { "classifier_name": "lc_classifier", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "SLSN", "probability": 0.148, "ranking": 2 }, { "classifier_name": "lc_classifier_periodic", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "RRL", "probability": 0.252, "ranking": 2 }, { "classifier_name": "lc_classifier_stochastic", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "CV/Nova", "probability": 0.74, "ranking": 1 }, { "classifier_name": "lc_classifier_transient", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "SLSN", "probability": 0.148, "ranking": 2 }, { "classifier_name": "stamp_classifier", "classifier_version": "stamp_classifier_1.0.0", "class_name": "asteroid", "probability": 0.0374948, "ranking": 5 }, { "classifier_name": "lc_classifier", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "QSO", "probability": 0.0, "ranking": 5 }, { "classifier_name": "lc_classifier_periodic", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "CEP", "probability": 0.164, "ranking": 3 }, { "classifier_name": "lc_classifier_stochastic", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "YSO", "probability": 0.024, "ranking": 5 }, { "classifier_name": "stamp_classifier", "classifier_version": "stamp_classifier_1.0.0", "class_name": "bogus", "probability": 0.049380366, "ranking": 4 }, { "classifier_name": "lc_classifier", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "AGN", "probability": 0.0, "ranking": 5 }, { "classifier_name": "lc_classifier_periodic", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "Periodic-Other", "probability": 0.136, "ranking": 4 }, { "classifier_name": "lc_classifier", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "Blazar", "probability": 0.0, "ranking": 5 }, { "classifier_name": "lc_classifier", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "CV/Nova", "probability": 0.0, "ranking": 5 }, { "classifier_name": "lc_classifier", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "YSO", "probability": 0.0, "ranking": 5 }, { "classifier_name": "lc_classifier", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "LPV", "probability": 0.0, "ranking": 5 }, { "classifier_name": "lc_classifier", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "E", "probability": 0.0, "ranking": 5 }, { "classifier_name": "lc_classifier", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "DSCT", "probability": 0.0, "ranking": 5 }, { "classifier_name": "lc_classifier", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "RRL", "probability": 0.0, "ranking": 5 }, { "classifier_name": "lc_classifier", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "CEP", "probability": 0.0, "ranking": 5 }, { "classifier_name": "lc_classifier", "classifier_version": "hierarchical_rf_1.1.0", "class_name": "Periodic-Other", "probability": 0.0, "ranking": 5 }]

        // uniqueValues function takes the dictionay and takes all the differents classifier_names and let all of the in a list, but without repetitions.
        function uniqueValues(db) {
            
            const classKeys = [];

            for (let i = 0; i < db.length; i++){
                if (!(classKeys.includes(db[i].classifier_name))){
                    classKeys.push(db[i].classifier_name);
                }        
            }
            return classKeys;
        }
        
        // generateDictionaries functions takes the uniqueValues return and generates a dictionary of empty dictionaries, one for every classifier_name in the uniqueValues return
        function generateDictionaries() {

            const uniqueKeys = uniqueValues(db);
            const result = {};

            for (let i = 0; i < uniqueKeys.length; i++) {
                result[uniqueKeys[i]] = {};
            }

            return [result,uniqueKeys];
        }

        // getData is the function that fill the dictionary generated in generateDictionaries. tha data is separated by his classfier_name and added as: class_name:probability
        // where class_name is the key and probability is the value
        function getData(db){

            const [principalDict,uniqueKeys] = generateDictionaries();

            for (let i = 0; i < db.length; i++){
                principalDict[db[i].classifier_name][db[i].class_name] = db[i].probability;
            }

            return [principalDict,uniqueKeys]
        }
        
        const [principalDict,uniqueKeys] = getData(db);

        // selector function returns the dictionary required in the initial moment and when the user selects another chart
        function selector(n){
            return principalDict[uniqueKeys[n]];
        }

        const ctx = document.getElementById('myChart').getContext('2d');
        const selectElement = document.getElementById('mySelect');

        let currentDict = selector(0);
        // Data is a variable required in config, and config with ctx are the values required to generate de chart
        const data = {
            labels: Object.keys(currentDict),
            datasets: [{
                label: 'Probabilities',
                data: Object.values(currentDict),
                fill: true,
                backgroundColor: 'rgba(255, 99, 132, 0.2)',
                borderColor: 'rgb(255, 99, 132)',
                pointBackgroundColor: 'rgb(255, 99, 132)',
                pointBorderColor: '#fff',
                pointHoverBackgroundColor: '#fff',
                pointHoverBorderColor: 'rgb(255, 99, 132)',
            }]
        };

        const config = {
            type: 'radar',
            data: data,
            options: {

                elements: {
                    line: {
                        borderWidth: 1,
                    },
                },
                scales: {
                    r: {
                        ticks: {
                            display: false,
                            maxTicksLimit: 5,

                        },
                        grid: {
                            color: 'white'
                        },
                        angleLines: {
                            color: 'white'
                        },
                    },

                },
                plugins: {
                    legend: {
                        display: false
                    }
                },
            }
        };
        // Function to capitalize just the first letter of a word
        function capitalize(word){
            return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
        }
        // Function that split the word by the _ and joins with spaces and capitalized words
        function changeTitles(uniquekeys){
            let keysTitle = [];

            for (let i = 0; i < uniqueKeys.length; i++){
                let splittedWord = uniqueKeys[i].split('_');
                let auxList = []
                for (let j = 0; j < splittedWord.length; j++){
                    auxList.push(capitalize(splittedWord[j]));
                }
                keysTitle.push(auxList.join(' '))
            }
            return keysTitle;
        }

        let keysTitle = changeTitles(uniqueKeys)

        // The next for loop generates the options in the select html automaticly and add values to the element
        for (let i = 0; i < uniqueKeys.length; i++){
            
            const option = document.createElement('option');

            option.value = uniqueKeys[i];
            option.text  = keysTitle[i];
            selectElement.appendChild(option);

        }
        // new Chart deploys the chart
        let myChart = new Chart(ctx, config);

        // this event listener takes the option selected by the user and update the chart values to deploy the new one.
        selectElement.addEventListener('change', function() {

            let currentDictChanged = selector(uniqueKeys.indexOf(this.value));
            myChart.data.labels = Object.keys(currentDictChanged)
            myChart.data.datasets.data = Object.keys(currentDictChanged)
            myChart.update();

        });

    </script>
</body>

</html>

